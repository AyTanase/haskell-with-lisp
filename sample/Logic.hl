#?(defun format-symbol (&rest args)
    (intern (apply #'format nil args)))

#?(defun nth-name (name n)
    (if (= n 1)
      name
      (format-symbol "~a~a" name n)))

#?(defun generate-1 (fix name n)
    `(|define| ,(nth-name name n) (,fix ,(nth-name name (1- n)))))

#?(defun generate (name m n)
    (let ((fix (format-symbol "fix~a" name)))
      (loop for i from m to n
        collect (generate-1 fix name i))))

#?(def-hs-macro |generate| (name m &optional n)
    `(progn ,@(generate name (if n m 2) (if n n m))))

#?(defoperator |apply| <*>)


(defmodule Logic)

(import Prelude (const apply))

#|
const :: (-> a b a)
apply :: (-> (-> a b c) (-> a b) a c)
|#


#|
apply       :: (-> (-> a b a) (-> a b) a a)
const       :: (-> a b a)
apply const :: (-> (-> a b) a a)
            :: (-> (-> a b a) a a)
|#
(type id (-> a a))
(define id (apply const const))


#|
x       :: a
g       :: (-> a b)
g x     :: b
f       :: (-> b c)
f (g x) :: c

const f         :: (-> a b c)
apply           :: (-> (-> a b c) (-> a b) a c)
apply (const f) :: (-> (-> a b) a c)

const apply
  :: (-> (-> b c) (-> a b c) (-> a b) a c)
apply
  :: (-> (-> (-> b c) (-> a b c) (-> a b) a c) (-> (-> b c) a b c) (-> b c) (-> a b) a c)
apply (const apply)
  :: (-> (-> (-> b c) a b c) (-> b c) (-> a b) a c)
const
  :: (-> (-> b c) a b c)
|#
(type compose (-> (-> b c) (-> a b) a c))
(define compose (apply (const apply) const))

#|
compose :: (-> (-> c d) (-> b c) b d)
compose f g y = f (g y)

compose2 :: (-> (-> c d) (-> a b c) a b d)
compose2 f g x = compose f (g x)

composeN' f g x = composeN f (g x)
composeN' f     = compose (composeN f)
composeN'       = compose compose composeN
|#
(define fixcompose #'(compose compose))
(generate compose 2)


#|
apply :: (-> (-> b c d) (-> b c) b d)
apply f g y = f y (g y)

apply2 :: (-> (-> a b c d) (-> a b c) a b d)
apply2 f g x = apply (f x) (g x)

applyN' f g x = applyN (f x) (g x)
              = compose applyN f x (g x)
applyN' f     = apply (compose applyN f)
applyN'       = compose2 apply compose applyN
|#
(define fixapply (compose2 apply compose))
(type apply2 (-> (-> a b c d) (-> a b c) a b d))
(generate apply 3)


#|
y     :: a
f     :: (-> a b c)
f y   :: (-> b c)
x     :: b
f y x :: c

f                 :: (-> a b c)
apply             :: (-> (-> a b c) (-> a b) a c)
apply f           :: (-> (-> a b) a c)
const x           :: (-> a b)
apply f (const x) :: (-> a c)

const f                :: (-> b a b c)
apply2                 :: (-> (-> b a b c) (-> b a b) b a c)
apply2 (const f)       :: (-> (-> b a b) b a c)
const                  :: (-> b a b)
apply2 (const f) const :: (-> b a c)

const        :: (-> (-> a b c) b a b c)
apply3       :: (-> (-> (-> a b c) b a b c) (-> (-> a b c) b a b) (-> a b c) b a c)
apply3 const :: (-> (-> (-> a b c) b a b) (-> a b c) b a c)
const const  :: (-> (-> a b c) b a b)
|#
(type flip (-> (-> a b c) b a c))
(define flip (apply3 const (const const)))

(type join (-> (-> a a b) a b))
(define join (flip apply id))

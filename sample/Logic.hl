#?(defun format-symbol (&rest args)
    (intern (apply #'format nil args)))

#?(defun nth-name (name n)
    (if (= n 1)
      name
      (format-symbol "~a~a" name n)))

#?(defun generate-1 (fix name n)
    `(|define| ,(nth-name name n) (,fix ,(nth-name name (1- n)))))

#?(defmacro |generate| (name n)
    (let ((fix (format-symbol "fix~a" name)))
      `(progn
         ,@(loop for i from 2 to n
             collect (generate-1 fix name i)))))


(defmodule Logic)

(import Prelude (const))

;; const :: (-> a b a)

(type axiom (-> (-> a b c) (-> a b) a c))
(define (axiom f g x) (f x (g x)))


#|
axiom       :: (-> (-> a b a) (-> a b) a a)
const       :: (-> a b a)
axiom const :: ((-> a b) a a)
            :: ((-> a b a) a a)
|#
(type id (-> a a))
(define id (axiom const const))


#|
x       :: a
g       :: (-> a b)
g x     :: b
f       :: (-> b c)
f (g x) :: c

const f         :: (-> a b c)
axiom           :: (-> (-> a b c) (-> a b) a c)
axiom (const f) :: (-> (-> a b) a c)

const axiom
  :: (-> (-> b c) (-> a b c) (-> a b) a c)
axiom
  :: (-> (-> (-> b c) (-> a b c) (-> a b) a c) (-> (-> b c) a b c) (-> b c) (-> a b) a c)
axiom (const axiom)
  :: (-> (-> (-> b c) a b c) (-> b c) (-> a b) a c)
const
  :: (-> (-> b c) a b c)
|#
(type compose (-> (-> b c) (-> a b) a c))
(define compose (axiom (const axiom) const))

#|
compose :: (-> (-> c d) (-> b c) b d)
compose f g y = f (g y)

compose2 :: (-> (-> c d) (-> a b c) a b d)
compose2 f g x = compose f (g x)

composeN' f g x = composeN f (g x)
composeN' f     = compose (composeN f)
composeN'       = compose compose composeN
|#
(define fixcompose (compose compose))
(generate compose 2)


#|
axiom :: (-> (-> b c d) (-> b c) b d)
axiom f g y = f y (g y)

axiom2 :: (-> (-> a b c d) (-> a b c) a b d)
axiom2 f g x = axiom (f x) (g x)

axiomN' f g x = axiomN (f x) (g x)
              = compose axiomN f x (g x)
axiomN' f     = axiom (compose axiomN f)
axiomN'       = compose2 axiom compose axiomN
|#
(define fixaxiom (compose2 axiom compose))
(generate axiom 3)


#|
y     :: a
f     :: (-> a b c)
f y   :: (-> b c)
x     :: b
f y x :: c

f                 :: (-> a b c)
axiom             :: (-> (-> a b c) (-> a b) a c)
axiom f           :: (-> (-> a b) a c)
const x           :: (-> a b)
axiom f (const x) :: (-> a c)

const f                :: (-> b a b c)
axiom2                 :: (-> (-> b a b c) (-> b a b) b a c)
axiom2 (const f)       :: (-> (-> b a b) b a c)
const                  :: (-> b a b)
axiom2 (const f) const :: (-> b a c)

const        :: (-> (-> a b c) b a b c)
axiom3       :: (-> (-> (-> a b c) b a b c) (-> (-> a b c) b a b) (-> a b c) b a c)
axiom3 const :: (-> (-> (-> a b c) b a b) (-> a b c) b a c)
const const  :: (-> (-> a b c) b a b)
|#
(type flip (-> (-> a b c) b a c))
(define flip (axiom3 const (const const)))

(extension FlexibleContexts
           FlexibleInstances
           MultiParamTypeClasses)

(defpackage Poly
  (:shadow Prelude negate + - *)
  (:use (:q Prelude) Classes)
  (:export (Poly :all) ppure))


(newtype (Poly a) (Poly (list a)) Show)

(instance (Eq (Poly a)) ((Eq a) (Group a))
  ((= (Poly us) (Poly vs))
    (labels ((zerop (xs)
               (hs:and (map (= zero) xs)))
             (equal (xs nil) (zerop xs))
             (equal (nil ys) (zerop ys))
             (equal ((cons x xs) (cons y ys))
               (and (= x y) (equal xs ys))))
      (equal us vs))))


(type ppure (-> a (Poly a)))
(define ppure (compose Poly list))

(type pmap (-> (-> a b) (Poly a) (Poly b)))
(define (pmap f (Poly xs)) (Poly (map f xs)))


(type add (=> (Group a) (-> (list a) (list a) (list a))))

(define (add xs nil) xs)

(define (add nil ys) ys)

(define (add (cons x xs) (cons y ys))
  (cons (+ x y) (add xs ys)))


(instance (Group (Poly a)) (:overlapping (Group a))
  (zero (Poly nil))
  (negate (pmap negate))
  ((+ (Poly xs) (Poly ys)) (Poly (add xs ys))))


(instance (Action a (Poly b)) (:overlapping (Action a b))
  (* (compose pmap *)))

(instance (Action (Poly a) (Poly b))
    (:overlapping (Action a b) (Group b))
  ((* _ (Poly nil)) (Poly nil))
  ((* (Poly us) (Poly (cons v vs)))
    (labels ((mul (y ys x zs)
               (cons (* x y) (add (* x ys) zs))))
      (Poly (foldr (mul v vs) nil us)))))


(instance (Ring (Poly r)) (:overlapping (Ring r))
  (unit (ppure unit)))


(instance (Num (Poly a)) ((Num a))
  (+ +) (- -) (* *)
  (negate negate)
  ((abs (Poly xs)) (ppure (sum (map abs xs))))
  (signum undefined)
  (fromInteger (compose ppure fromInteger)))

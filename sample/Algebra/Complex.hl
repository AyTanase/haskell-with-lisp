(extension FlexibleInstances MultiParamTypeClasses)

(defpackage Complex
  (:shadow Prelude negate + - * (Fractional :all))
  (:use (:q Prelude) Classes)
  (:export (Complex :all) cpure))


(data (Complex a) (Complex :name (re a) (im a)) Eq)

(instance (Show (Complex a)) ((Show a))
  ((show (Complex x y))
    (where ((shows' (showsPrec 11)))
      (append "Complex " (shows' x " ") (shows' y ""))))
  ((showsPrec p)
    (compose (showParen (>= p 11)) append show)))


(type cpure (=> (Group a) (-> a (Complex a))))
(define cpure (flip Complex zero))

(type cmap (-> (-> a b) (Complex a) (Complex b)))
(define (cmap f (Complex x y)) (Complex (f x) (f y)))

(instance (Group (Complex a)) (:overlapping (Group a))
  (zero (cpure zero))
  (negate (cmap negate))
  ((+ (Complex u v) (Complex x y)) (Complex (+ u x) (+ v y))))


(instance (Action a (Complex b)) (:overlapping (Action a b))
  (* (compose cmap *)))

(instance (Action (Complex a) (Complex b))
    (:overlapping (Action a b) (Group b))
  ((* (Complex u v) (Complex x y))
    (Complex (- (* u x) (* v y)) (+ (* u y) (* v x)))))


(instance (Ring (Complex r)) ((Ring r))
  (unit (cpure unit)))


(instance (Div a (Complex b)) (:overlapping (Div a b))
  (/ (flip (compose cmap (flip /)))))

(instance (Div (Complex a) (Complex b))
    ((Div a b) (Ring a) (Group b))
  ((/ z (Complex x y))
    (* (Complex x (- y)) (/ z (+ (* x x) (* y y))))))


(instance (Num (Complex a)) ((Num a))
  (+ +) (- -) (* *)
  (negate negate)
  (abs undefined)
  (signum undefined)
  (fromInteger (compose cpure fromInteger)))

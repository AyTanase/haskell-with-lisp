(defpackage Parse
  (:use Common Data.Function Data.Bifunctor)
  (:export parse))


#{ Q :: Quantifier }#
(deftype QMaker (-> (-> NFA NFA NFA) NFA NFA))

(type (makeStar makePlus makeOpt) QMaker)

(define (makeStar method f)
  (fix (lambda (g) (method (compose f g) id))))

(define (makePlus method f)
  (compose f (makeStar method f)))

(define (makeOpt method f) (method f id))


(deftype Parser (-> NFA String (tuple NFA String)))
(type parse' Parser)


#{ G :: Greediness }#
(type checkG (-> QMaker Parser))

(define (checkG make f ?(#\+ . xs))
  (tuple (make atomic f) xs))

(define (checkG make f ?(#\? . xs))
  (tuple (make (flip split) f) xs))

(define (checkG make f xs)
  (tuple (make split f) xs))


(type checkQ' Parser)
(define (checkQ' f ?(#\* . xs)) (checkG makeStar f xs))
(define (checkQ' f ?(#\+ . xs)) (checkG makePlus f xs))
(define (checkQ' f ?(#\? . xs)) (checkG makeOpt  f xs))
(define (checkQ' f xs) (tuple f xs))

(type checkQ (-> NFA Parser))
(define (checkQ f g xs)
  (let (((tuple h ys) (checkQ' g xs)))
    (parse' (compose f h) ys)))

(type parseChar (-> NFA Char String (tuple NFA String)))
(define (parseChar f x xs) (checkQ f (Compare x) xs))


(type parseGroup (-> String (tuple NFA String)))

(define (parseGroup ?(#\? #\> . xs))
  (first cut (parse' id xs)))

(define (parseGroup xs) (parse' id xs))


(define (parse' f nil) (tuple f nil))

(define (parse' f ?(#\\ x . xs)) (parseChar f x xs))

(define (parse' f ?(#\( . xs))
  (uncurry (checkQ f) (parseGroup xs)))

(define (parse' f ?(#\) . xs)) (tuple f xs))

(define (parse' f ?(#\| . xs))
  (first (split f) (parse' id xs)))

(define (parse' f ?(x . xs)) (parseChar f x xs))


(type parse (-> String Op))
(define (parse xs) (fst (parse' id xs) Finite))
